(* Dichiarazione dei Namespace: Identificatori univoci che associano un prefisso ad un URI.*)
namespace owl="http://www.w3.org/2002/07/owl#"
namespace rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
namespace www="http://www.persone#"
namespace xml="http://www.w3.org/XML/1998/namespace"
namespace xsd="http://www.w3.org/2001/XMLSchema#"
namespace rdfs="http://www.w3.org/2000/01/rdf-schema#";;

(* Tipi principali *)
type Ontology = <rdf:RDF xml:base=String> [ Thing * ] 

type Thing = Ont | Property | Class | Individual

type Ont = <owl:Ontology rdf:about=String> []

type Property = <owl:ObjectProperty rdf:about=String> []

type Class = <owl:Class rdf:about=String> [ ClassAttr * ]
type ClassAttr = EqClass | SubClass
type EqClass = <owl:equivalentClass> [ <owl:Restriction> [ AnyXml * ] ]
type SubClass = <rdfs:subClassOf rdf:resource=String> []

type Individual = <owl:NamedIndividual rdf:about=String> [ IndAttr * ]
type IndAttr = TypeInd | PropInd | Name
type Name = <rdfs:comment> String
type TypeInd = <rdf:type rdf:resource=String> []
type PropInd = <_ rdf:resource=String> [];;

(* Function to safely load an XML file with error handling *)
let fun safe_load_xml (path : Latin1) : AnyXml =
  try 
    let ret_val = load_xml path in  (* Attempt to load the XML file *)
    print "Loaded successfully\n";  (* Print success message *)
    ret_val                         (* Return the loaded XML *)
  with 
    _ -> 
      print "Error loading XML, syntax error\n";  (* Print error message *)
      <rdf:RDF>[];;  (* Return an empty RDF structure in case of an error *)


(* Funzione per filtrare gli attributi validi di una classe *)
let fun filter_valid_attributes (atts : [ AnyXml* ]) : [ AnyXml* ] =
  match atts with
    | [] -> []  (* Lista vuota restituita se non ci sono attributi *)
    | ((s & SubClass) @ rest) -> [s] @ filter_valid_attributes rest  (* Aggiunge SubClass alla lista filtrata *)
    | ((s & EqClass) @ rest) -> [s] @ filter_valid_attributes rest   (* Aggiunge EqClass alla lista filtrata *)
    | ((s & Label) @ rest) -> [s] @ filter_valid_attributes rest     (* Aggiunge Label alla lista filtrata *)
    | ((s & Note) @ rest) -> [s] @ filter_valid_attributes rest      (* Aggiunge Note alla lista filtrata *)
    | (_ @ rest) -> filter_valid_attributes rest;;  (* Scarta gli altri attributi non validi *)

(* Funzione per filtrare solo le classi valide con almeno un attributo valido *)
let fun filter_valid_classes (classes : [ AnyXml* ]) : [ AnyXml* ] =
  match classes with
    | [] -> []
    | (<owl:Class rdf:about=cls> att @ rest) ->
        let valid_attributes = filter_valid_attributes att in
        if valid_attributes != [] then
          [ <owl:Class rdf:about=cls> valid_attributes ] @ filter_valid_classes rest
        else
          filter_valid_classes rest  (* Rimuove la classe se non ha attributi validi *)
    | (_ @ rest) -> filter_valid_classes rest;;  (* Rimuove elementi non `owl:Class` *)

(* Funzione per trasformare l'ontologia mantenendo solo elementi validi *)
let fun transform_compatible_elements (ontology : AnyXml) : AnyXml =
  match ontology with
    | <rdf:RDF xml:base=uri> classes -> 
        print "Processing RDF structure...\n";  (* Debugging output *)
        let transformed_classes = filter_valid_classes classes in
        <rdf:RDF xml:base=uri> transformed_classes
    | _ -> 
        print "Non-compatible RDF structure\n";  (* Debugging output *)
        <rdf:RDF>[];;  (* Se l'input non Ã¨ un RDF valido, restituisce un RDF vuoto *)

(* Function to validate if an XML structure conforms to the ontology definition (Dynamic check)*)
let fun validate_elements (input : AnyXml) : Bool = 
  match input with
    | _ & Ontology -> `true  (* If the input matches the Ontology type, return true *)
    | _ -> `false;;          (* Otherwise, return false *)



(* Function to count the number of elements in a list *)
let fun listLength ( [ Any* ] -> Int )
  | ([ _ ] @ y) -> 1 + listLength y
  | [] -> 0;;

(* Function to check if all elements in a list are true *)
let fun andList ( [ Bool* ] -> Bool )
  | ([ x ] @ y) -> (x && (andList y))
  | [] -> `true;;

(* Function to validate and transform the ontology if needed *)
let fun verify_and_transform_ontology (input : AnyXml) : AnyXml =
    if (validate_elements input) then
      (print "Valid Ontology\n"; input)  (* Ontology is valid, return true *)
    else
      (print "Invalid Ontology, transforming...\n"; 
      let transformed = transform_compatible_elements input in
        let transformed_valid = validate_elements transformed in
          if transformed_valid then 
            (print "Ontology valid after transforming: True\n"; transformed)
          else 
            (print "Ontology valid after transforming: False\n"; input)
          );;

(* Main entry point to load and validate the XML file. *)
(* Load the XML ontology file safely *)
let xml_file :? Ontology = safe_load_xml "IO/persone.rdf";;

if (validate_elements xml_file) then
  print "Outer check valid ontology\n"
else
  print "Outer check non valid ontology\n";;

(* Verify ontology validity and transform if necessary *)
let valid_ontology = verify_and_transform_ontology xml_file;;

(* Save the transformed ontology if valid *)
if (validate_elements valid_ontology) then
  dump_to_file_utf8 "IO/output.xml" (print_xml_utf8 valid_ontology)
else
  print "Failed to validate or transform ontology\n";;